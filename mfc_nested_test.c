#include "core/thread.h"
#include <gui/gui.h>
#include <notification/notification.h>
#include <notification/notification_messages.h>
#include <nfc/protocols/nfc_protocol.h>
#include <nfc/protocols/mf_classic/mf_classic.h>
#include <nfc/protocols/mf_classic/mf_classic_poller.h>
#include <nfc/protocols/iso14443_3a/iso14443_3a.h>
#include <nfc/protocols/iso14443_3a/iso14443_3a_poller.h>
#include <furi.h>
#include <furi_hal_nfc.h>
#include <nfc/nfc.h>
#include <nfc/nfc_poller.h>

/* generated by fbt from .png files in images folder */
#include <mfc_nested_test_icons.h>

#define MFC_NESTED_TEST_COMPLETE_EVENT (1UL << 0)

typedef enum {
    AppStateWaiting,
    AppStateTestOk,
    AppStateTestFailed,
} AppState;

typedef struct {
    AppState state;
    Nfc* nfc;
    const char* error;
} AppContext;

typedef struct {
    FuriThreadId thread_id;
    bool result;
    const char* error;
} PollerContext;

const char* TAG = "mfc_nested_test";

static void render_callback(Canvas* const canvas, void* context) {
    AppContext* ctx = context;
    canvas_draw_frame(canvas, 0, 0, 128, 64);

    switch(ctx->state) {
    case AppStateWaiting:
        canvas_set_font(canvas, FontPrimary);
        canvas_draw_str_aligned(canvas, 4, 4, AlignLeft, AlignTop, "Press O to start test");
        break;
    case AppStateTestOk:
        canvas_set_font(canvas, FontPrimary);
        canvas_draw_str_aligned(canvas, 4, 4, AlignLeft, AlignTop, "Test successful!");
        break;
    case AppStateTestFailed:
        canvas_set_font(canvas, FontPrimary);
        canvas_draw_str_aligned(canvas, 4, 4, AlignLeft, AlignTop, "Test failed!");
        canvas_set_font(canvas, FontSecondary);
        canvas_draw_str_aligned(canvas, 4, 16, AlignLeft, AlignTop, ctx->error);
        break;
    }
}

static void input_callback(InputEvent* input_event, FuriMessageQueue* event_queue) {
    furi_assert(event_queue);

    furi_message_queue_put(event_queue, input_event, FuriWaitForever);
}

static void log_block(int num, MfClassicBlock* block) {
    FURI_LOG_I(
        TAG,
        "read block %d: %02X %02X %02X %02X %02X %02X %02X %02X %02X %02X %02X %02X %02X %02X %02X %02X",
        num,
        block->data[0],
        block->data[1],
        block->data[2],
        block->data[3],
        block->data[4],
        block->data[5],
        block->data[6],
        block->data[7],
        block->data[8],
        block->data[9],
        block->data[10],
        block->data[11],
        block->data[12],
        block->data[13],
        block->data[14],
        block->data[15]);
}

static bool
    test_auth(MfClassicPoller* poller, uint8_t block, MfClassicKeyType key, bool is_nested) {
    uint8_t key_type_nibble = key == MfClassicKeyTypeA ? 0xA0 : 0xB0;
    uint8_t sector_nibble = block >> 2;
    uint8_t key_byte = key_type_nibble | sector_nibble;
    MfClassicKey key0B = {.data = {key_byte, key_byte, key_byte, key_byte, key_byte, key_byte}};

    MfClassicError error;
    MfClassicAuthContext auth_ctx = {};
    if(is_nested) {
        error = mf_classic_poller_auth_nested(poller, block, &key0B, key, &auth_ctx);
    } else {
        error = mf_classic_poller_auth(poller, block, &key0B, key, &auth_ctx);
    }

    if(error != MfClassicErrorNone) {
        FURI_LOG_E(
            TAG,
            "%s auth-%s(%d) failed with key %02X*6: %d",
            is_nested ? "nested" : "plain",
            key == MfClassicKeyTypeA ? "a" : "b",
            block,
            key_byte,
            error);
        return false;
    }

    FURI_LOG_I(
        TAG,
        "%s auth-%s(%d) success with key %02X*6",
        is_nested ? "nested" : "plain",
        key == MfClassicKeyTypeA ? "a" : "b",
        block,
        key_byte);
    return true;
}

static bool nested_auth_loop(MfClassicPoller* poller) {
    for(uint8_t i = 0; i < 16; i++) {
        uint8_t block = i << 2;
        if(!test_auth(poller, block, MfClassicKeyTypeA, true)) {
            return false;
        }
        if(!test_auth(poller, block, MfClassicKeyTypeB, true)) {
            return false;
        }
    }
    return true;
}

static bool dump_sector(MfClassicPoller* poller, uint8_t sector) {
    MfClassicBlock block;
    uint8_t block_start = sector << 2;
    for(uint8_t i = block_start; i < block_start + 4; i++) {
        if(mf_classic_poller_read_block(poller, i, &block) != MfClassicErrorNone) {
            FURI_LOG_E(TAG, "read(%d) failed", i);
            return false;
        }
        log_block(i, &block);
    }
    return true;
}

static NfcCommand poller_test_cb(NfcGenericEventEx event, void* context) {
    furi_assert(event.poller);
    furi_assert(event.parent_event_data);
    furi_assert(context);

    PollerContext* ctx = context;
    Iso14443_3aPollerEvent* iso14443_3a_event = event.parent_event_data;
    MfClassicPoller* poller = event.poller;

    if(iso14443_3a_event->type == Iso14443_3aPollerEventTypeReady) {
        ctx->result = false;
        do {
            if(!test_auth(poller, 0, MfClassicKeyTypeB, false)) {
                ctx->error = "plain auth-b(0) failed";
                break;
            }
            if(!dump_sector(poller, 0)) {
                ctx->error = "dump sector 0 failed";
                break;
            }
            if(!test_auth(poller, 4, MfClassicKeyTypeB, true)) {
                ctx->error = "nested auth-b(4) failed";
                break;
            }
            if(!dump_sector(poller, 1)) {
                ctx->error = "dump sector 1 failed";
                break;
            }
            if(!nested_auth_loop(poller)) {
                ctx->error = "nested auth loop failed";
                break;
            }
            ctx->result = true;
        } while(false);
    } else if(iso14443_3a_event->type == Iso14443_3aPollerEventTypeError) {
        ctx->result = false;
        ctx->error = "iso14443_3a poller error";
    }

    furi_thread_flags_set(ctx->thread_id, MFC_NESTED_TEST_COMPLETE_EVENT);

    return NfcCommandStop;
}

static bool test_stuff(AppContext* ctx) {
    NfcPoller* poller = nfc_poller_alloc(ctx->nfc, NfcProtocolMfClassic);
    PollerContext poller_ctx = {
        .thread_id = furi_thread_get_current_id(),
        .error = NULL,
    };

    nfc_poller_start_ex(poller, poller_test_cb, &poller_ctx);
    furi_thread_flags_wait(MFC_NESTED_TEST_COMPLETE_EVENT, FuriFlagWaitAny, FuriWaitForever);
    furi_thread_flags_clear(MFC_NESTED_TEST_COMPLETE_EVENT);
    nfc_poller_stop(poller);
    nfc_poller_free(poller);

    ctx->error = poller_ctx.error;
    return poller_ctx.result;
}

int32_t mfc_nested_test_app(void* p) {
    UNUSED(p);

    FURI_LOG_I(TAG, "Hello world");
    FURI_LOG_I(TAG, "I'm mfc_nested_test!");

    AppContext ctx = {
        .state = AppStateWaiting,
        .nfc = nfc_alloc(),
    };

    NotificationApp* notifications = furi_record_open(RECORD_NOTIFICATION);
    Gui* gui = furi_record_open(RECORD_GUI);
    FuriMessageQueue* event_queue = furi_message_queue_alloc(8, sizeof(InputEvent));
    ViewPort* view_port = view_port_alloc();
    view_port_draw_callback_set(view_port, render_callback, &ctx);
    view_port_input_callback_set(view_port, input_callback, event_queue);
    gui_add_view_port(gui, view_port, GuiLayerFullscreen);

    for(bool processing = true; processing;) {
        InputEvent input_event;
        FuriStatus event_status = furi_message_queue_get(event_queue, &input_event, 100);
        if(event_status == FuriStatusOk && input_event.type == InputTypeShort) {
            if(input_event.key == InputKeyBack) {
                processing = false;
            } else {
                switch(ctx.state) {
                case AppStateWaiting:
                    if(input_event.key == InputKeyOk) {
                        notification_message(notifications, &sequence_blink_start_cyan);
                        bool test_ok = test_stuff(&ctx);

                        ctx.state = test_ok ? AppStateTestOk : AppStateTestFailed;

                        notification_message(notifications, &sequence_blink_stop);
                        notification_message(
                            notifications, test_ok ? &sequence_success : &sequence_error);
                    }
                    break;
                case AppStateTestOk:
                case AppStateTestFailed:
                    ctx.state = AppStateWaiting;
                    break;
                }
            }
        }
        view_port_update(view_port);
    }
    nfc_free(ctx.nfc);
    view_port_enabled_set(view_port, false);
    gui_remove_view_port(gui, view_port);
    view_port_free(view_port);
    furi_message_queue_free(event_queue);

    furi_record_close(RECORD_NOTIFICATION);
    furi_record_close(RECORD_GUI);

    return 0;
}
